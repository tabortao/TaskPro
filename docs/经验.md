# TaskPro 开发经验总结

本文档总结了 TaskPro 项目开发过程中的所有问题、解决方案和最佳实践。

## 📋 目录

- [项目初始化](#项目初始化)
- [数据库设计与迁移](#数据库设计与迁移)
- [话题管理功能](#话题管理功能)
- [任务管理功能](#任务管理功能)
- [标签系统](#标签系统)
- [用户认证](#用户认证)
- [文件上传](#文件上传)
- [界面交互优化](#界面交互优化)
- [性能优化](#性能优化)
- [常见问题](#常见问题)

---

## 项目初始化

### 1. 技术栈选择

**问题**：如何选择合适的技术栈？

**解决方案**：
- **Taro 4.1.5**：跨平台支持，一套代码多端运行
- **React 18.3.1**：成熟的组件化开发
- **TypeScript**：类型安全，减少运行时错误
- **TailwindCSS**：原子化 CSS，快速开发
- **Supabase**：开源 BaaS，快速搭建后端

**经验**：
- Taro 适合需要同时支持小程序和 H5 的项目
- TailwindCSS 配合 weapp-tailwindcss 可以在小程序中使用
- Supabase 提供了完整的后端服务，减少开发成本

### 2. 项目结构设计

**最佳实践**：
```
src/
├── components/     # 公共组件
├── pages/          # 页面
├── db/             # 数据库 API 和类型
├── store/          # 状态管理
├── utils/          # 工具函数
└── client/         # 客户端配置
```

**经验**：
- 按功能模块组织代码，而不是按文件类型
- 数据库操作统一封装在 `db/api.ts` 中
- 类型定义集中在 `db/types.ts` 中

---

## 数据库设计与迁移

### 1. 表结构设计

**问题**：如何设计合理的数据库表结构？

**解决方案**：
- **profiles**：用户信息表
- **topics**：话题表（项目）
- **tasks**：任务表
- **tags**：标签表（支持层级）
- **task_tags**：任务标签关联表
- **attachments**：附件表

**经验**：
- 使用 UUID 作为主键，避免 ID 冲突
- 使用外键约束保证数据一致性
- 使用 `ON DELETE CASCADE` 自动清理关联数据
- 添加 `created_at` 和 `updated_at` 字段记录时间

### 2. 数据库迁移

**问题**：如何管理数据库变更？

**解决方案**：
- 使用迁移文件管理数据库变更
- 每个迁移文件包含详细的注释说明
- 迁移文件按顺序编号（00001, 00002, ...）

**示例**：
```sql
/*
# 创建话题和任务表

1. 新建表
   - `topics` - 话题表
   - `tasks` - 任务表

2. 安全策略
   - 启用 RLS
   - 用户只能访问自己的数据
*/

CREATE TABLE IF NOT EXISTS topics (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  name text NOT NULL,
  description text,
  icon_url text,
  is_archived boolean DEFAULT false,
  is_pinned boolean DEFAULT false,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
```

**经验**：
- 迁移文件要包含详细的注释
- 使用 `IF NOT EXISTS` 避免重复创建
- 先创建表，再创建索引和策略
- 测试迁移文件的回滚操作

### 3. Row Level Security (RLS)

**问题**：如何保证数据安全？

**解决方案**：
- 所有表启用 RLS
- 创建策略控制访问权限
- 用户只能访问自己的数据
- 管理员可以访问所有数据

**示例**：
```sql
ALTER TABLE topics ENABLE ROW LEVEL SECURITY;

CREATE POLICY "用户可以查看自己的话题" ON topics
  FOR SELECT TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "管理员可以访问所有话题" ON topics
  FOR ALL TO authenticated USING (is_admin(auth.uid()));
```

**经验**：
- 始终启用 RLS，除非有特殊需求
- 策略要覆盖所有操作（SELECT, INSERT, UPDATE, DELETE）
- 使用辅助函数（如 `is_admin`）简化策略
- 测试策略是否正确限制了访问

---

## 话题管理功能

### 1. 话题创建和编辑

**问题**：如何实现话题的创建和编辑？

**解决方案**：
- 使用统一的表单组件 `topic-form`
- 通过 URL 参数区分创建和编辑模式
- 支持 Emoji 和图片作为话题图标

**代码示例**：
```typescript
// 创建话题
await createTopic({
  user_id: userId,
  name,
  description: description || null,
  icon_url: iconEmoji || null,
  is_archived: false,
  is_pinned: false
})

// 更新话题
await updateTopic(topicId, {
  name,
  description: description || null,
  icon_url: iconEmoji || null
})
```

**经验**：
- 表单验证要在前端和后端都做
- 使用 `icon_url` 字段同时存储 Emoji 和图片 URL
- 通过 `startsWith('http')` 判断是 Emoji 还是 URL

### 2. 话题图标显示

**问题**：如何正确显示话题图标（Emoji 或图片）？

**解决方案**：
```tsx
{topic.icon_url ? (
  !topic.icon_url.startsWith('http') ? (
    // Emoji 显示
    <View className="w-12 h-12 rounded-lg flex items-center justify-center bg-gradient-primary">
      <Text className="text-3xl">{topic.icon_url}</Text>
    </View>
  ) : (
    // 图片 URL 显示
    <Image src={getImageUrl(topic.icon_url)} className="w-12 h-12 rounded-lg" mode="aspectFill" />
  )
) : (
  // 默认图标
  <View className="w-12 h-12 bg-primary rounded-lg flex items-center justify-center">
    <View className="i-mdi-folder text-2xl text-white" />
  </View>
)}
```

**经验**：
- 判断 `icon_url` 是否以 `http` 开头
- Emoji 使用 Text 组件显示
- 图片使用 Image 组件显示
- 提供默认图标作为后备

### 3. 话题置顶和归档

**问题**：如何实现话题的置顶和归档功能？

**解决方案**：
- 添加 `is_pinned` 和 `is_archived` 字段
- 置顶话题显示在列表顶部
- 归档话题不在主列表显示

**代码示例**：
```typescript
// 置顶话题
await updateTopic(topicId, {is_pinned: !topic.is_pinned})

// 归档话题
await updateTopic(topicId, {is_archived: true})

// 查询话题时过滤归档
const data = await getTopics(userId, '', false) // false = 不包含归档
```

**经验**：
- 置顶和归档是独立的功能
- 归档的话题可以在专门的页面查看
- 置顶话题要在查询时排序

---

## 任务管理功能

### 1. Chat-style 任务输入

**问题**：如何实现类似聊天的任务输入体验？

**解决方案**：
- 使用底部固定的输入框组件 `GlobalInput`
- 支持多行文本输入
- 自动解析标签（`#标签/子标签`）
- 输入框始终可见，方便快速添加任务

**代码示例**：
```tsx
<GlobalInput topicId={topicId} onTaskCreated={loadData} />
```

**经验**：
- 输入框要固定在底部，使用 `position: fixed`
- 任务列表要添加底部 padding，避免被输入框遮挡
- 支持 Enter 键提交，Shift+Enter 换行

### 2. 任务列表底部遮挡问题

**问题**：任务列表最后一个任务被底部输入框遮挡。

**解决方案**：
```tsx
<ScrollView scrollY className="flex-1">
  <View className="p-4 pb-24"> {/* 添加 pb-24 底部 padding */}
    {/* 任务列表 */}
  </View>
</ScrollView>
```

**经验**：
- 底部 padding 要大于输入框高度
- 使用 `pb-24`（96px）作为安全区域
- 测试滚动到底部时最后一个任务是否完全可见

### 3. 任务状态管理

**问题**：如何管理任务的多种状态（完成、置顶、收藏）？

**解决方案**：
- 使用布尔字段：`is_completed`, `is_pinned`, `is_favorite`
- 提供快捷操作按钮
- 使用左滑右滑手势操作

**代码示例**：
```typescript
// 切换完成状态
await updateTask(taskId, {is_completed: !task.is_completed})

// 切换置顶状态
await updateTask(taskId, {is_pinned: !task.is_pinned})

// 切换收藏状态
await updateTask(taskId, {is_favorite: !task.is_favorite})
```

**经验**：
- 状态切换要有视觉反馈
- 使用 Toast 提示操作结果
- 操作后立即刷新列表

### 4. 任务卡片交互优化

**问题**：如何优化任务卡片的交互体验？

**解决方案**：
- 创建 `SwipeableTaskCard` 组件
- 左滑显示编辑和删除按钮
- 右滑显示置顶和收藏按钮
- 加大选择框尺寸（从 w-5 h-5 改为 w-7 h-7）

**代码示例**：
```tsx
<SwipeableTaskCard
  task={task}
  onDelete={handleDeleteTask}
  onEdit={handleEditTask}
  onTogglePin={handleTogglePin}
  onToggleFavorite={handleToggleFavorite}
  onToggleComplete={handleToggleComplete}
  onClick={() => Taro.navigateTo({url: `/pages/task-detail/index?taskId=${task.id}`})}
/>
```

**经验**：
- 滑动距离超过 80px 自动展开按钮
- 点击卡片收回滑动状态
- 使用不同颜色区分按钮功能
- 左滑：编辑（蓝色 #3498DB）、删除（红色）
- 右滑：置顶（主色）、收藏（橙色 #F39C12）

---

## 标签系统

### 1. 标签解析

**问题**：如何解析任务内容中的标签？

**解决方案**：
```typescript
function parseTaskContent(content: string) {
  const tagRegex = /#([^\s#]+)/g
  const tags: string[] = []
  let match

  while ((match = tagRegex.exec(content)) !== null) {
    tags.push(match[1])
  }

  return {
    content: content.replace(tagRegex, '').trim(),
    tags
  }
}
```

**经验**：
- 使用正则表达式匹配 `#标签` 格式
- 支持 `#标签/子标签` 层级结构
- 解析后从内容中移除标签文本

### 2. 标签层级结构

**问题**：如何实现标签的层级结构？

**解决方案**：
- 使用 `parent_id` 字段建立父子关系
- 解析 `#标签/子标签` 格式
- 自动创建父标签和子标签

**代码示例**：
```typescript
async function createTagHierarchy(tagPath: string, userId: string, topicId: string) {
  const parts = tagPath.split('/')
  let parentId = null

  for (const part of parts) {
    const tag = await findOrCreateTag(part, userId, topicId, parentId)
    parentId = tag.id
  }

  return parentId
}
```

**经验**：
- 标签名称要唯一（同一层级下）
- 支持多级嵌套
- 查询时要递归获取子标签

### 3. 标签管理界面

**问题**：如何设计标签管理界面？

**解决方案**：
- 使用侧边栏抽屉 `TagDrawer`
- 显示标签列表和层级关系
- 支持标签的创建、编辑、删除
- 支持标签颜色和 Emoji 自定义

**经验**：
- 标签列表要显示层级关系
- 使用缩进表示层级
- 提供快捷操作按钮
- 支持拖拽排序（可选）

---

## 用户认证

### 1. 登录方式

**问题**：如何实现多种登录方式？

**解决方案**：
- 支持微信授权登录
- 支持邮箱密码登录
- 使用 Supabase Auth

**代码示例**：
```typescript
// 邮箱密码登录
const {data, error} = await supabase.auth.signInWithPassword({
  email,
  password
})

// 微信授权登录（需要配置）
const {data, error} = await supabase.auth.signInWithOAuth({
  provider: 'wechat'
})
```

**经验**：
- 密码要求：至少 6 位，包含数字和字母
- 邮箱要验证格式
- 登录失败要显示友好的错误提示
- 登录成功后跳转到主页

### 2. 认证状态管理

**问题**：如何管理用户的认证状态？

**解决方案**：
- 使用 Zustand 管理认证状态
- 监听 Supabase Auth 状态变化
- 实现认证守卫

**代码示例**：
```typescript
export const useAuthStore = create<AuthStore>((set) => ({
  user: null,
  profile: null,
  setUser: (user) => set({user}),
  setProfile: (profile) => set({profile}),
  logout: async () => {
    await supabase.auth.signOut()
    set({user: null, profile: null})
  }
}))

// 认证守卫
export async function authGuard() {
  const {data: {user}} = await supabase.auth.getUser()
  if (!user) {
    Taro.redirectTo({url: '/pages/login/index'})
    return false
  }
  return true
}
```

**经验**：
- 页面加载时检查认证状态
- 使用 `useDidShow` 钩子检查
- 未登录用户重定向到登录页
- 登录后返回原页面

---

## 文件上传

### 1. Supabase Storage

**问题**：如何实现文件上传？

**解决方案**：
- 使用 Supabase Storage 存储文件
- 创建存储桶（Bucket）
- 配置访问权限

**代码示例**：
```typescript
// 上传文件
const file = await Taro.chooseImage({count: 1})
const filePath = file.tempFilePaths[0]

const {data, error} = await supabase.storage
  .from('taskpro-attachments')
  .upload(`${userId}/${Date.now()}.jpg`, filePath)

if (error) throw error

// 获取公开 URL
const {data: {publicUrl}} = supabase.storage
  .from('taskpro-attachments')
  .getPublicUrl(data.path)
```

**经验**：
- 文件名要包含用户 ID 和时间戳，避免冲突
- 使用公开 URL 访问文件
- 设置文件大小限制（默认 1MB）
- 支持图片预览和下载

### 2. S3 自定义存储

**问题**：如何支持用户自定义 S3 存储？

**解决方案**：
- 用户可以配置自己的 S3 凭证
- 使用 AWS SDK 上传文件
- 存储配置在用户 profile 中

**代码示例**：
```typescript
import {S3Client, PutObjectCommand} from '@aws-sdk/client-s3'

const s3Client = new S3Client({
  region: s3Config.region,
  credentials: {
    accessKeyId: s3Config.accessKeyId,
    secretAccessKey: s3Config.secretAccessKey
  }
})

await s3Client.send(new PutObjectCommand({
  Bucket: s3Config.bucket,
  Key: fileName,
  Body: fileData
}))
```

**经验**：
- S3 配置要加密存储
- 提供配置验证功能
- 支持多种存储服务（S3, OSS, COS）
- 优先使用 Supabase Storage，S3 作为备选

---

## 界面交互优化

### 1. 左滑右滑手势

**问题**：如何实现流畅的左滑右滑交互？

**解决方案**：
- 监听 `touchStart`, `touchMove`, `touchEnd` 事件
- 计算滑动距离和方向
- 使用 CSS `transform` 实现动画

**代码示例**：
```typescript
const [startX, setStartX] = useState(0)
const [translateX, setTranslateX] = useState(0)

const handleTouchStart = (e: any) => {
  setStartX(e.touches[0].clientX)
}

const handleTouchMove = (e: any) => {
  const currentX = e.touches[0].clientX
  const diff = currentX - startX

  // 限制滑动距离
  if (diff < 0 && diff > -160) {
    setTranslateX(diff)
  } else if (diff > 0 && diff < 160) {
    setTranslateX(diff)
  }
}

const handleTouchEnd = () => {
  // 超过 80px 自动展开
  if (translateX < -80) {
    setTranslateX(-160)
  } else if (translateX > 80) {
    setTranslateX(160)
  } else {
    setTranslateX(0)
  }
}
```

**经验**：
- 滑动距离要有上限（160px）
- 超过阈值（80px）自动展开
- 使用 `transition-transform` 实现平滑动画
- 点击卡片收回滑动状态

### 2. 主页菜单优化

**问题**：如何优化主页菜单的用户体验？

**解决方案**：
- 使用侧边栏菜单
- 在"进行中"上方增加"我的话题"选项
- 取消主页"我的话题"文字显示
- 仅在"进行中"模式显示标题

**经验**：
- 菜单要清晰明了
- 使用图标增强识别度
- 当前选中项要高亮显示
- 点击菜单项后自动关闭侧边栏

### 3. 响应式设计

**问题**：如何适配不同屏幕尺寸？

**解决方案**：
- 使用 TailwindCSS 响应式类
- 使用 Flexbox 布局
- 使用相对单位（rem, %）

**经验**：
- 小程序默认不需要响应式断点
- 使用 `flex-col` 垂直布局
- 使用 `gap` 控制间距
- 使用 `w-full` 占满宽度

---

## 性能优化

### 1. 列表渲染优化

**问题**：如何优化长列表的渲染性能？

**解决方案**：
- 使用 `key` 属性
- 避免在渲染函数中创建新对象
- 使用 `useMemo` 缓存计算结果
- 使用 `useCallback` 缓存回调函数

**代码示例**：
```typescript
const displayTasks = useMemo(() => {
  return tasks.filter(task => {
    if (activeTab === 'ongoing') return !task.is_completed
    if (activeTab === 'completed') return task.is_completed
    return true
  })
}, [tasks, activeTab])

const handleToggleComplete = useCallback(async (taskId: string) => {
  // 处理逻辑
}, [])
```

**经验**：
- 列表项要有唯一的 `key`
- 避免在 `map` 中使用箭头函数
- 使用 `useMemo` 缓存过滤和排序结果
- 使用 `useCallback` 缓存事件处理函数

### 2. 数据库查询优化

**问题**：如何优化数据库查询性能？

**解决方案**：
- 创建索引
- 使用 `select` 指定字段
- 使用 `limit` 限制返回数量
- 使用 `order` 排序

**代码示例**：
```typescript
const {data, error} = await supabase
  .from('tasks')
  .select('id, content, is_completed, created_at')
  .eq('user_id', userId)
  .eq('topic_id', topicId)
  .order('is_pinned', {ascending: false})
  .order('created_at', {ascending: false})
  .limit(50)
```

**经验**：
- 为常用查询字段创建索引
- 避免 `select('*')`，只查询需要的字段
- 使用 `limit` 限制返回数量
- 使用 `order` 在数据库层面排序

### 3. 状态管理优化

**问题**：如何优化状态管理？

**解决方案**：
- 使用 Zustand 轻量级状态管理
- 避免不必要的全局状态
- 使用局部状态（useState）
- 使用 Immer 处理复杂状态

**经验**：
- 只把需要共享的状态放到全局
- 页面级状态使用 `useState`
- 避免频繁更新全局状态
- 使用 `useDidShow` 刷新数据

---

## 常见问题

### 1. Taro 路由问题

**问题**：使用 `navigateTo` 跳转 TabBar 页面失败。

**解决方案**：
- TabBar 页面使用 `switchTab`
- 普通页面使用 `navigateTo`

```typescript
// 错误
Taro.navigateTo({url: '/pages/topics/index'}) // topics 是 TabBar 页面

// 正确
Taro.switchTab({url: '/pages/topics/index'})
```

### 2. TailwindCSS 类名冲突

**问题**：TailwindCSS 类名冲突导致样式异常。

**解决方案**：
- 避免同时使用冲突的类名
- 使用自定义 utility 类
- 使用 `@apply` 指令

```tsx
// 错误：text-primary 和 text-transparent 冲突
<Text className="text-primary text-transparent">文本</Text>

// 正确：使用自定义类
<Text className="gradient-text">文本</Text>
```

### 3. Supabase RLS 权限问题

**问题**：查询数据返回空，但数据库中有数据。

**解决方案**：
- 检查 RLS 策略是否正确
- 确认用户已登录
- 使用 `service_role` key 测试

```sql
-- 检查策略
SELECT * FROM pg_policies WHERE tablename = 'tasks';

-- 临时禁用 RLS 测试
ALTER TABLE tasks DISABLE ROW LEVEL SECURITY;
```

### 4. 图片上传失败

**问题**：图片上传到 Supabase Storage 失败。

**解决方案**：
- 检查存储桶是否存在
- 检查文件大小是否超限
- 检查文件名是否包含特殊字符

```typescript
// 文件名不能包含中文
const fileName = `${userId}/${Date.now()}.jpg` // 正确
const fileName = `${userId}/图片.jpg` // 错误
```

### 5. 小程序包大小超限

**问题**：小程序包大小超过 2MB 限制。

**解决方案**：
- 使用外部图片 URL，不要下载到本地
- 删除未使用的依赖
- 使用分包加载
- 压缩图片和代码

```json
// project.config.json
{
  "setting": {
    "minified": true,
    "es6": true
  }
}
```

### 6. useEffect 依赖警告

**问题**：useEffect 依赖数组缺少依赖项。

**解决方案**：
- 使用 `useCallback` 包装函数
- 使用 `useMemo` 包装对象和数组
- 添加完整的依赖数组

```typescript
// 错误
useEffect(() => {
  loadData()
}, []) // loadData 未在依赖中

// 正确
const loadData = useCallback(async () => {
  // 加载数据
}, [dependency1, dependency2])

useEffect(() => {
  loadData()
}, [loadData])
```

### 7. 类型定义不匹配

**问题**：TypeScript 类型错误。

**解决方案**：
- 保持类型定义与数据库表结构一致
- 使用 `Partial<T>` 处理部分更新
- 使用 `Omit<T, K>` 排除字段

```typescript
// 更新时使用 Partial
async function updateTopic(id: string, data: Partial<Topic>) {
  // ...
}

// 创建时排除自动生成的字段
type CreateTopic = Omit<Topic, 'id' | 'created_at' | 'updated_at'>
```

---

## 总结

### 核心经验

1. **项目结构**：按功能模块组织代码，保持清晰的目录结构
2. **数据库设计**：使用迁移文件管理变更，启用 RLS 保证安全
3. **组件设计**：使用函数式组件和 Hooks，保持组件简单和可复用
4. **状态管理**：使用 Zustand 管理全局状态，局部状态使用 useState
5. **样式开发**：使用 TailwindCSS 原子类，避免内联样式
6. **性能优化**：使用 useMemo 和 useCallback，优化列表渲染
7. **用户体验**：提供流畅的交互动画，友好的错误提示
8. **代码质量**：使用 TypeScript 保证类型安全，使用 Biome 检查代码

### 最佳实践

1. **代码规范**：遵循 Biome 规范，保持代码风格一致
2. **类型安全**：使用 TypeScript，避免运行时错误
3. **错误处理**：使用 try-catch 捕获错误，显示友好提示
4. **数据验证**：前端和后端都要验证数据
5. **安全策略**：启用 RLS，保护用户数据
6. **性能监控**：使用 Taro 性能监控工具
7. **测试覆盖**：编写单元测试和集成测试
8. **文档维护**：保持文档更新，记录重要决策

### 未来优化方向

1. **实时协作**：使用 Supabase Realtime 实现多人协作
2. **离线支持**：使用 IndexedDB 缓存数据，支持离线使用
3. **数据同步**：实现数据的增量同步
4. **性能优化**：使用虚拟列表优化长列表渲染
5. **国际化**：支持多语言
6. **主题切换**：支持深色模式
7. **数据导出**：支持导出任务数据
8. **统计分析**：添加任务统计和分析功能

---

<div align="center">

**持续更新中...**

如有问题或建议，欢迎提交 Issue！

</div>
